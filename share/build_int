#!/bin/bash
###############################################################################
# integrate the latest `git clone` of a given repo
#
# intended to run from /srv/http/inc/int
###############################################################################

# basic vars, change these: ###################################################
#change to non-zero to enable
opt_debug=0
opt_verbose=1

#exit codes:
EC_NORM=0 # normal
EC_FAIL=1 # irregular termination
EC_PIDF=2 # PID file error
EC_MIGR=3 # problem migrating files to live
EC_REPO=4 # git, ssh, or repository issue
EC_CONF=5 # configuration, startup issues

[[ -r $1 ]] && source $1 || exit $EC_CONF #replace below fictitious values
# should expand to HostName github.com in ~/.ssh/config [see ssh_config(5)]:
git_server=${git_server:-github_serv}
git_repo=${git_repo:-${git_server}:jzacsh/anyproject}
git_sshkey=${git_sshkey:-/srv/http/inc/botname_id_rsa}
gitland=${gitland:-mess_dir-www}
http_dir=${http_dir:-/srv/http/www}
###############################################################################

# basic script setup ##########################################################
opt_debug=${opt_debug-0}
opt_verbose=${opt_verbose-0}
expected='/srv/http/inc/int'
mess="${PWD-expected}"
runfile="$mess/.running"
git_land="$mess/$gitland"
param='' #cleared and used as necessary

#colors:
col_end='\033[0m' #cap
col_blk='\e[0;30m'
col_red='\e[1;31m'
col_grn='\e[1;32m'
col_ylw='\e[1;33m'
col_blu='\e[1;34m'
col_wht='\e[0;37m'
#TOOD: wrap this "color" block in if statement in case run to a log file
fresh=0 #indication that the repo is not new, and is to be compared upstream
###############################################################################

# script helpers: #############################################################
if_debug() { (( $opt_debug > 0)) && return 0 || return 1; }
if_verbose() { (( $opt_verbose > 0)) && return 0 || return 1; }

cleanup() {
  dbg 'starting cleanup().'

  if [[ -f $runfile ]];then
    if [[ -w $runfile ]];then
      if_verbose && param='v' || param=''
      rm -f${param} $runfile
    else
      err "cannot delete pid file: $runfile"
      return $EC_PIDF
    fi
  fi
}

die() {
  dbg "starting die(${col_red}${@}${col_end})."

  stamp "Exiting integration build of\n\t$git_repo"

  dbg "the following was passed to die():\n$@"

  # clean up PID file. dirty param, optional
  [[ $2 = 'd' ]] && printer 'leaving PID file behind.' || cleanup

  # clean up ssh keychain
  local clean_fail
  clean_key
  [[ $? -eq 0 ]] || clean_fail=$ECPIDF

  # exit with optional error code param
  local number='^[0-9]+([.][0-9]+)?$'
  [[ $1 =~ $number || $1 -eq 0  ]] && exit $1 || exit ${clean_fail-$EC_FAIL}
}

clean_key() {
  ssh-add -d ${git_sshkey}
}

printer() {
  echo -e "${col_grn}::${col_end} ${@}"
}

stamp() {
  printer "$(date --rfc-3339=seconds) ${col_ylw}::${col_end} ${@}"
}

err() {
  echo -e "${col_ylw}::${col_end} ${col_red}ERROR:${col_end} ${@}" >&2
}

verb() {
  if_verbose || return
  echo -e "${col_ylw}::${col_end} ${@}"
}

dbg() {
  if_debug || return
  echo -e "${col_ylw}::${col_end} ${col_blu}DEBUG:${col_end} ${@}"
}

conf_debug() {
  if_debug && echo || return
  dbg 'starting conf_debug(), settings debugger.'

  dbg "mess dir is: $mess"
  dbg "run file is: $runfile"
  dbg "git repo is: $git_repo"
  dbg "ssh key is: $git_sshkey"
  dbg "git landing is: $git_land"
  dbg 'printing git server access'
  ssh $git_server expand
  dbg 'printing all fingerprints in ssh agent'
  ssh-add -l
  dbg 'finished conf_debug(), settings debugger.\n'
}

# program functions: ##########################################################
prep_env() {
  dbg 'starting prep_env().'

  conf_debug

  verb 'creating PID file..'
  if [[ -f $runfile ]];then
    err 'script already running or PID was left behind file..'
    die $EC_PIDF d
  else
    #create PID file
    touch $runfile

    if [[ ! -f $runfile ]];then
      err 'problem creating PID file..'
      die $EC_PIDF
    fi
  fi

  verb 'making sure PWD is expected location..'
  cd $mess
  verb "current directory is: $PWD"

  verb 'making sure ssh key is in keychain...'
  if [[ -r $git_sshkey ]];then
    local tmp=$(mktemp);
    local outp="$(keychain --quiet $git_sshkey &>$tmp)"
    if [[ $(wc -c < $tmp) = 0 ]];then
      verb 'ssh key added to keychain.'
    else
      err "problem, below, loading the following ssh key...\n\t$git_sshkey"
      verb "$(cat $tmp)"
      die $EC_REPO
    fi
  else
    err "cannot read below ssh key file...\n\t$git_sshkey"
    die $EC_REPO
  fi

  local msg="ensuring the following 'landing directory' actually exists..."
  verb "$msg\n\t$git_land"
  if [[ -e $git_land ]]; then
    verb "landing directory found, continuing normally"
    dbg 'landing directory has `stat` of:'
    if_debug && stat $git_land
    dbg "\`fresh\` bool is currently: $fresh."
    dbg "marking current local repo status as NOT 'fresh'."
    fresh=0
    dbg "\`fresh\` bool is now: $fresh."
  else
    verb "no landing directory found"
    verb "cloning latest repo into landing directory"
    git clone $git_repo $git_land
    dbg "\`fresh\` bool is currently: $fresh."
    dbg "marking current local repo status as 'fresh'."
    fresh=1
    dbg "\`fresh\` bool is now: $fresh."
  fi
}

get_latest() {
  dbg 'starting get_latest().'

  dbg "\`fresh\` bool is: $fresh."

  if [[ $fresh -eq 0 ]]; then
    # local repo is not "fresh" (already exists). We can assume integration has
    # been done before, and will simply check for upstream changes.
    _compare_latest
  else
    # if local repo is fresh, script wil continue in main integrate the latest
    verb 'local repo seems to have just been built, moving on to integration'
  fi
}

_compare_latest() {
  dbg 'starting _compare_latest().'

  if [[ -d $git_land && -w $git_land ]];then
    verb 'entering local repo...'
    cd $git_land
    verb 'comparing to upstream...'
    local commits="$(git fetch && git log ..origin/master | grep ^commit)"
    if [[ -z $commits ]]; then
      #exit early, no updates available
      verb 'Nothing to do. No upstream changes available.'
      die $EC_NORM
    else
      #updates available
      verb "the following upstream updates available\n$commits"
      verb 'starting `git` pull...'
      git pull origin master
    fi
  else
    #cannot access local repo
    local error='Unable to access the following (local repo), checked with `-d` and `-w`'
    err "$error\n\t$git_land"
    die $EC_MIGR
  fi
}

build_live() {
  dbg 'starting build_live()'

  if_verbose && param='v' || param=''
  if [[ -r $git_land ]] && [[ -w $http_dir ]];then
    local msg='copying latest build into live http docs...'
    verb "$msg\n\tfrom $git_land -> $http_dir"
    for file in $git_land/*; do
      cp -r${param} $file $http_dir/
    done

    verb 'copying any hidden files, as well...'
    for file in $git_land/.*; do
      local b=$(basename $file)
      if [[ ! $b = '.' ]] && [[ ! $b = '..' ]] && [[ ! $b = '.git' ]];then
        dbg "copying: $file"
        cp -r${param} $file $http_dir/
      else
        dbg "skipping suspect file: $file"
      fi
    done
    verb 'file integration complete'
  else
    err 'improper permissions for latest fetch and/or http docs directory.'

    #debugging block
    if [[ if_verb ]]; then
      #check read permissions from local repository
      if [[ -r $git_land ]];then
        verb "improper read permissions to following landing dir/\n\t$git_land"
        verb '`stat`s appear to be:'
        if_verb && stat $git_land
      fi

      #check write permissions to http directory
      if [[ -w $http_dir  ]];then
        verb "improper write permissions to following httpd dir/\n\t$http_dir"
        verb '`stat`s appear to be:'
        if_verb && stat $http_dir
      fi
    fi

    die $EC_MIGR
  fi
}

trap die SIGINT
# main sequence: ##############################################################
stamp "Starting integration build of\n\t$git_repo"
prep_env
get_latest
build_live
stamp "Cleaning up integration build of\n\t$git_repo"
clean_key
cleanup
