#!/bin/bash
 #@TODO: use this! #!/usr/bin/env bash

 #@TODO: change all user-facing wording to use "punch-card" as verbage instead
 # of "time-card"

###############################################################################
_CARD=~/.config/punchcard
_DELIM=' '

PUNCH_CARD=${PUNCH_CARD:-$_CARD}
PUNCH_DELIM=${PUNCH_DELIM:-$_DELIM}
OPT_PROJECT=${PUNCH_CLIENT}

#see /usr/include/sysexits.h
E_ERROR=1  #general error
E_USAGE=64 #command line usage error
E_DATAF=65 #data format error

# getops configuration: #######################################################

declare -rA OPTS=(
    [c:]='client  Specify the client/project being referenced, "__".'
    [C]='List all clients/projects on time-card.'
    [D:]='timestamp  Delete all in/out time-card entries at epoch, "__".'
    [h]='Help message.'
    [L]='List all entries, for every project, on time-card.'
    [l]='List all time-card made under a project. See -c.'
    [p]='Punch in/out for a "client"/"project" being referenced. See -c.'
    [q]='Quiet mode, print minimal output and even fail quietly.'
    [d]='Delete all time-card entries made under a project. See -c.'
    [s]='Output timestamps as epoch, intended as shell input. See eval(1p).'
    [t]='Sum of total time-card entries under project. See -c.'
)

# functions: ##################################################################
error() {
    (( OPT_QUIET )) || echo -e "Error: ${@}" >&2
}

die() {
    #@TODO: make a call to same ROLLBACK func. used by TRAP
    exit ${1:-'0'}
}

help() {
    #print the regular usage
    usage

    #build the help section
    declare -a HELP
    local i=0
    for opt in "${!OPTS[@]}"; do
        HELP[$i]=${opt/:/}
        ((++i))
    done
    i=0
    for opt in "${OPTS[@]}"; do
        local keyword=${opt%%  *}
        #@TODO: get the first keyword in output to capitalize.
        keyword=${keyword^^}
        local explain=${opt/'__'/$keyword}
        HELP[$i]="-${HELP[$i]}\t${explain/  / - }"
        ((++i))
    done

    #print help section
    echo "\
    OPTIONS:" >&2
    for help in "${HELP[@]}"; do
        echo -e "\t$help" >&2
    done

    die $1
}

usage() {
    local _n=$(basename $0)
    local flags=$(
        for opt in ${!OPTS[@]}; do
            [[ ${opt:1:1} = : ]] || echo -n $opt
        done
    )
    local i=0 n x=0
    local argflags=$(
        for opt in ${!OPTS[@]}; do
            if [[ ${opt:1:1} = : ]];then
                (( x )) && OR=' | '
                echo -en "$OR-${opt/:/} "
                n=0
                for arg in "${OPTS[@]}"; do
                    if (( n == i ));then
                        arg=${arg%% *}
                        echo -en "${arg,,}"
                        break;
                    fi
                    ((++n))
                done
                ((++x))
            fi
            ((++i))
        done
    )

    echo "$_n [$flags] [ $argflags ] [ note... ]
    Simple time card utility, lets you punch in, out and get paid.

    ${_n^} generally takes a client/subject of what you're working *for* and
    optionaly a quick note of what you're working *on*, then stores a timestamp
    in your local punch-card database.

    Called with no arguments ${_n^} prints your current time on the clock.

    ENVIRONMENT VARIABLES
        PUNCH_CARD   - location of your punch-card database. Defaults to $_CARD.
        PUNCH_DELIM  - field delimeter for data output. Defaults to '$_DELIM'.
        PUNCH_CLIENT - Client/Project name to use. See -c.
" >&2

    (( $# )) && die ${@}
}

# helpers: ####################################################################

## schema: ###################################
#   unix timestamp of the "punch"
# - punch       INTEGER NOT NULL PRIMARY KEY,
#
#   0 or 1. 0: punched out; 1: punch in
# - status      INTEGER NOT NULL,
#
#   project/client for which this work is for.
# - project     TEXT NOT NULL,
#
#   optional text note describing this work.
# - note        TEXT
##############################################
DB_TABLE_NAME='punchcard'
DB_CREATE_TABLE="
CREATE TABLE $DB_TABLE_NAME (
    punch       INTEGER NOT NULL PRIMARY KEY,
    status      INTEGER NOT NULL,
    project     TEXT NOT NULL,
    note        TEXT
);
"

db_sql() {
    sqlite3 $PUNCH_CARD "${@}"
}

db_schema() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        (somehow) check \$CREATE_TABLE against sqlite3's '.schema' command
    "
    return 99
}

db_out_sanitize() {
    while read line;do
        [[ -n $line ]] && echo "$line"
    done
}

db_punch() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
      will INSERT into DB with notes, after taking care of logic:
      - what is state of timecard? in or out?
    "
    return 99
}

create_db() {
    (( OPT_QUIET )) && return $E_DATAF
    local initialize
    echo -en "Would you like to initialize a punch-card, here:
\t$PUNCH_CARD ?"
    local prompt=" [Y\n]  "
    read -p $prompt initialize
    [[ -z $initialize || ${initialize,,} = y ]] || return $E_DATAF
    db_sql "$DB_CREATE_TABLE"
}

reset() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        create a ROLLBACK call for call by TRAP and DIE.
    "
    return 99
}

# punchcard tools: ############################################################

init_storage() {
    if [[ $(file -bL $PUNCH_CARD 2>/dev/null | grep -i 'sqlite') ]];then
        #punch card looks like an sqlite file.
        if [[ ! -w $PUNCH_CARD ]];then
            error "No write-access to punch-card."
            die $E_DATAF
        fi
    else
        #punch card does not look like an sqlite file.
        if [[ -f $PUNCH_CARD ]];then
            #punch card at least likes like _some_ kind of file.
            if (( 10#$(stat -L --printf='%s' $PUNCH_CARD 2>/dev/null) ));then
                #punch card has something else in it.
                error "Punch-card does not seem to be an sqlite3 database:\n\t$(file -L $PUNCH_CARD)"
                die $E_DATAF
            else
                #punch card is an empty file. create tables?
                error "Punch-card is not yet formatted."
                [[ -w $PUNCH_CARD && -r $PUNCH_CARD ]] && create_db || die $?
            fi
        else
            #punch card does not exist. create it?
            error "Could not find punch-card\n\twas expecting: '$PUNCH_CARD'."
            [[ -w $(dirname $PUNCH_CARD) ]] && create_db || die $?
        fi
    fi
}

check_schema() {
    #@TODO: this if fragile. there must be a _proper_, standard way to do this.
    # this will fail if even the columns are created in a different order.
    if [[ $(diff -u <(echo "$DB_CREATE_TABLE" | db_out_sanitize) <(db_sql ".schema $DB_TABLE_NAME" | db_out_sanitize)) ]];then
        error "Punch-card does not seem to be in proper format:\n\t$PUNCH_CARD"
        die $E_DATAF
    fi
}

need_client() {
    if [[ -z $OPT_PROJECT ]];then
        error "Client not specified, expected -c. See -h for more."
        die $E_USAGE
    fi
}

current() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
      report on current punch-card status.
      - are you punched into a project? how long, so far and which project(s)?
      - not punched into anything? print a message saying so and exit non-zero
    "
    #@TODO: must respect the $OPT_CLEAN, and not print PROJECT name
    #@TODO: must respect PUNCH_DELIM
}

delete() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        remove all entries for a given project, '$OPT_PROJECT'
    "
}

list() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        list all existing timecard entries, for a given project, '$OPT_PROJECT'.
        [project] [total time]
    "
    #@TODO: must respect the $OPT_CLEAN
    #@TODO: must respect PUNCH_DELIM
}

punch() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
      create a database entry with current time stamp for given project,
      '$OPT_PROJECT', either the in or out entry, depending on what is
      currently in the database.
    "
}
data_dump() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        list all entries timecard in two columns, sorted exactly in sequence of
        entry.:
        [project A] [time in]
        [project B] [time in]
        [project A] [time out]
        [project B] [time out]
        ...
    "
    #@TODO: must respect the $OPT_CLEAN
    #@TODO: must respect PUNCH_DELIM
}

projects() {
    local t q r
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        list all PROJECTS on your timecard in two columns, eg.:
        [project] [total time]
        ...
    ###################################################################
    "
    q="SELECT DISTINCT project FROM $DB_TABLE_NAME ORDER BY project ASC;"

    (( OPT_CLEAN )) && t='' || t='%Y-%m-%d %H:%M:%S'
    while read result ;do
        t=$(project_total "$result")
        echo "$result $t"
    done < <(db_sql "$q")
    #@TODO: must respect the $OPT_CLEAN
    #@TODO: must respect the $OPT_QUIET, by not outputting "total time"
    #@TODO: must respect PUNCH_DELIM
}

project_total() {
    local p=$1 i=1 s total=0
    [[ -z $p ]] && return 1
    local q="SELECT punch FROM $DB_TALBE_NAME where project='$p' ORDER BY punch"

    #loop through each punch
    while read stamp;do
        if (( i % 2 ));then
            #on "start" stamp
            s="$stamp"
        else
            #on "end" stamp
            total=$(( total + $(( stamp - s )) ))
        fi
        (( ++i ))
    done < <(db_sql "$q")

    echo $total
}

remove() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        remove the in and out entries for a given timestamp, '$OPT_DELETE'
    "
}

spent() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        report a sum of time spent on a given project, '$OPT_PROJECT'
    "
    #@TODO: must respect the $OPT_CLEAN, by outputting a sum in seconds.
    #@TODO: must respect PUNCH_DELIM
}

# parse args: #################################################################
#@TODO: create a TRAP that will rollback transactions, `reset`
if (( $# ));then

    #build an array of possible options, all set to false
    declare -A OPT_RUN
    for option in "${!OPTS[@]}"; do
        OPT_RUN["${option/:/}"]=0
    done

    #parse arguments
    while getopts ":$(printf "%s" "${!OPTS[@]}")" option; do
        case $option in
            c)
                declare -r OPT_PROJECT=$OPTARG
                ;;
            C)
                #projects()
                OPT_RUN[$option]=1
                ;;
            D)
                declare -r OPT_DELETE=$OPTARG
                #remove()
                OPT_RUN[$option]=1
                ;;
            h)
                help
                ;;
            l)
                #list()
                OPT_RUN[$option]=1
                ;;
            L)
                #list()
                OPT_RUN[$option]=1
                ;;
            p)
                #punch()
                OPT_RUN[$option]=1
                ;;
            q)
                declare -r OPT_QUIET=1
                ;;
            d)
                #delete()
                OPT_RUN[$option]=1
                ;;
            s)
                declare -r OPT_CLEAN=1
                ;;
            t)
                #spent()
                OPT_RUN[$option]=1
                ;;
            \?)
                error "-$OPTARG is not a valid option. See -h for help."
                die $E_USAGE
                ;;
            :)
                error "-$OPTARG requires an argument. See -h for help."
                die $E_USAGE
                ;;
        esac
    done
  #@TODO: figure out how to make this work, only store non-getopts stuff:
  # shift $((OPTIND+1))
  # declare -r OPT_NOTE="${@}"
  # echo -e "OPT_NOTE is:\n\t${OPT_NOTE}"
else
    #no arguments were passed
    init_storage
    current
    die $?
fi

# main: #######################################################################
# - Try to run functions in a sensible sequence. ##############################

#
# Some sanity checking.
#

#functions that need a client to be specified:
if (( OPT_RUN[t] ||
    OPT_RUN[d] ||
    OPT_RUN[p] ||
    OPT_RUN[l] ));then
    need_client
fi

init_storage
check_schema

#
# Run one-off functions and die.
#
# for cleanliness of output
# that that covers all the db content should not be run with other functions.
#

if (( OPT_RUN[C] ));then
    projects
    die $?
fi

if (( OPT_RUN[L] ));then
    data_dump
    die $?
fi

#
# Make all changes before running any queries.
#

if (( OPT_RUN[p] ));then
    punch
fi

if (( OPT_RUN[d] ));then
    delete
fi

if (( OPT_RUN[D] ));then
    remove
fi

#
# Calculate and output all reporting.
#

if (( OPT_RUN[l] ));then
    list
fi

if (( OPT_RUN[t] ));then
    spent
fi
