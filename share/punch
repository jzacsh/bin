#!/bin/bash
 #@TODO: use this! #!/usr/bin/env bash

 if [[ $(type sqlite3 &>/dev/null ) ]];then
     echo "$(basename $0) relies on sqlite3, which was not found on this system." >&2
    exit 1
fi

 #@TODO: change all user-facing wording to use "punch-card" as verbage instead
 # of "time-card"

###############################################################################
_CARD=~/.config/punchcard
_DELIM=' '

PUNCH_CARD=${PUNCH_CARD:-$_CARD}
PUNCH_DELIM=${PUNCH_DELIM:-$_DELIM}
OPT_PROJECT=${PUNCH_CLIENT}

#see /usr/include/sysexits.h
E_ERROR=1  #general error
E_USAGE=64 #command line usage error
E_DATAF=65 #data format error

# getops configuration: #######################################################

declare -rA OPTS=(
    [c:]='client  Specify the client/project being referenced, "__".'
    [C]='List all clients/projects on time-card.'
    [D:]='timestamp  Delete all in/out time-card entries at epoch, "__".'
    [h]='Help message.'
    [L]='List all entries, for every project, on time-card.'
    [l]='List all time-card made under a project. See -c.'
    [p]='Punch in/out for a "client"/"project" being referenced. See -c.'
    [q]='Quiet mode, print minimal output and even fail quietly.'
    [d]='Delete all time-card entries made under a project. See -c.'
    [s]='Output timestamps as epoch, intended as shell input. See eval(1p).'
    [t]='Sum of total time-card entries under project. See -c.'
)

# functions: ##################################################################

NUMERIC_REGEX='^[0-9]+([.][0-9]+)?$'

error() {
    (( OPT_QUIET )) || echo -e "Error: ${@}" >&2
}

die() {
    #@TODO: make a call to same ROLLBACK func. used by TRAP
    exit ${1:-'0'}
}

help() {
    #print the regular usage
    usage

    #build the help section
    declare -a HELP
    local i=0
    for opt in "${!OPTS[@]}"; do
        HELP[$i]=${opt/:/}
        ((++i))
    done
    i=0
    for opt in "${OPTS[@]}"; do
        local keyword=${opt%%  *}
        #@TODO: get the first keyword in output to capitalize.
        keyword=${keyword^^}
        local explain=${opt/'__'/$keyword}
        HELP[$i]="-${HELP[$i]}\t${explain/  / - }"
        ((++i))
    done

    #print help section
    echo "\
    OPTIONS:" >&2
    for help in "${HELP[@]}"; do
        echo -e "\t$help" >&2
    done

    die $1
}

usage() {
    local _n=$(basename $0)
    local flags=$(
        for opt in ${!OPTS[@]}; do
            [[ ${opt:1:1} = : ]] || echo -n $opt
        done
    )
    local i=0 n x=0
    local argflags=$(
        for opt in ${!OPTS[@]}; do
            if [[ ${opt:1:1} = : ]];then
                (( x )) && OR=' | '
                echo -en "$OR-${opt/:/} "
                n=0
                for arg in "${OPTS[@]}"; do
                    if (( n == i ));then
                        arg=${arg%% *}
                        echo -en "${arg,,}"
                        break;
                    fi
                    ((++n))
                done
                ((++x))
            fi
            ((++i))
        done
    )

    echo "$_n [$flags] [ $argflags ] [ note... ]
    Simple time card utility, lets you punch in, out and get paid.

    ${_n^} generally takes a client/subject of what you're working *for* and
    optionaly a quick note of what you're working *on*, then stores a timestamp
    in your local punch-card database.

    Called with no arguments ${_n^} prints your current time on the clock.

    ENVIRONMENT VARIABLES
        PUNCH_CARD   - location of your punch-card database. Defaults to $_CARD.
        PUNCH_DELIM  - field delimeter for data output. Defaults to '$_DELIM'.
        PUNCH_CLIENT - Client/Project name to use. See -c.
" >&2

    (( $# )) && die ${@}
}

# helpers: ####################################################################

## schema: ###################################
#   unix timestamp of the "punch"
# - punch       INTEGER NOT NULL PRIMARY KEY,
#
#   0 or 1. 0: punched out; 1: punch in
# - status      INTEGER NOT NULL,
#
#   project/client for which this work is for.
# - project     TEXT NOT NULL,
#
#   optional text note describing this work.
# - note        TEXT
##############################################
DB_TABLE_NAME='punchcard'
DB_CREATE_TABLE="
CREATE TABLE $DB_TABLE_NAME (
    punch       INTEGER NOT NULL PRIMARY KEY,
    status      INTEGER NOT NULL,
    project     TEXT NOT NULL,
    note        TEXT
);
"

db_sql() {
    local opts=' '
#   (( OPT_QUIET )) && opts='-noheader' || opts="-header"

    #run query
    sqlite3 $opts \
        -separator "$PUNCH_DELIM" \
        $PUNCH_CARD "${@}"
}

db_schema() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        (somehow) check \$CREATE_TABLE against sqlite3's '.schema' command
    "
    return 99
}

db_out_sanitize() {
    while read line;do
        [[ -n $line ]] && echo "$line"
    done
}

db_punch() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
      will INSERT into DB with notes, after taking care of logic:
      - what is state of timecard? in or out?
    "
    return 99
}

create_db() {
    (( OPT_QUIET )) && return $E_DATAF
    local initialize
    echo -en "Would you like to initialize a punch-card, here:
\t$PUNCH_CARD ?"
    local prompt=" [Y\n]  "
    read -p $prompt initialize
    [[ -z $initialize || ${initialize,,} = y ]] || return $E_DATAF
    db_sql "$DB_CREATE_TABLE"
}

reset() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        create a ROLLBACK call for call by TRAP and DIE.
    "
    return 99
}

# punchcard tools: ############################################################

init_storage() {
    if [[ $(file -bL $PUNCH_CARD 2>/dev/null | grep -i 'sqlite') ]];then
        #punch card looks like an sqlite file.
        if [[ ! -w $PUNCH_CARD ]];then
            error "No write-access to punch-card."
            die $E_DATAF
        fi
    else
        #punch card does not look like an sqlite file.
        if [[ -f $PUNCH_CARD ]];then
            #punch card at least likes like _some_ kind of file.
            if (( 10#$(stat -L --printf='%s' $PUNCH_CARD 2>/dev/null) ));then
                #punch card has something else in it.
                error "Punch-card does not seem to be an sqlite3 database:\n\t$(file -L $PUNCH_CARD)"
                die $E_DATAF
            else
                #punch card is an empty file. create tables?
                error "Punch-card is not yet formatted."
                [[ -w $PUNCH_CARD && -r $PUNCH_CARD ]] && create_db || die $?
            fi
        else
            #punch card does not exist. create it?
            error "Could not find punch-card\n\twas expecting: '$PUNCH_CARD'."
            [[ -w $(dirname $PUNCH_CARD) ]] && create_db || die $?
        fi
    fi
}

check_schema() {
    #@TODO: this if fragile. there must be a _proper_, standard way to do this.
    # this will fail if even the columns are created in a different order.
    if [[ $(diff -u <(echo "$DB_CREATE_TABLE" | db_out_sanitize) <(db_sql ".schema $DB_TABLE_NAME" | db_out_sanitize)) ]];then
        error "Punch-card does not seem to be in proper format:\n\t$PUNCH_CARD"
        die $E_DATAF
    fi
}

need_client() {
    if [[ -z $OPT_PROJECT ]];then
        error "Client not specified, expected -c. See -h for more."
        die $E_USAGE
    fi
}

current() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
      report on current punch-card status.
      - are you punched into a project? how long, so far and which project(s)?
      - not punched into anything? print a message saying so and exit non-zero
    "
    #@TODO: must respect the $OPT_CLEAN, and not print PROJECT name
    #@TODO: must respect PUNCH_DELIM
}

delete() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        remove all entries for a given project, '$OPT_PROJECT'
    "
}

list() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        list all existing timecard entries, for a given project, '$OPT_PROJECT'.
        [project] [total time]
    "
    #@TODO: must respect the $OPT_CLEAN
    #@TODO: must respect PUNCH_DELIM
}

punch() {
    #@TODO: make this fail/ask user which project he's checking out of. if none
    # have been checked into, fail - saying you need to specify a client when
    # checking in

    # build query #############################################
    local insert_project
    local insert_status #punch in, by default
    local insert_note=${OPT_NOTE:-'NULL'}
    local q i=0 proj_punched=0
    declare -a in_projects

    local stat_return
    if [[ -n $OPT_PROJECT ]];then
        insert_project=$OPT_PROJECT
        #determine if we need to punch in or out for this project.
        stat_return=$(project_status "$OPT_PROJECT")
        echo "last punch status for $OPT_PROJECT was: $stat_return"
        if [[ $stat_return =~ $NUMERIC_REGEX ]];then
            insert_status=$(( 10#$stat_return ))
            insert_status=$(( ! $insert_status ))
        else
            #we are punching in, there is no previous record of this project
            insert_status=1
        fi
        echo "last punch status for $OPT_PROJECT will be: $insert_status"
    else
        #project not specified, implied punching out, figure out which project.
        insert_status=0
        local list="
            SELECT DISTINCT project
            FROM $DB_TABLE_NAME
            ORDER BY punch
        ;"

        #check each project to find out what's punched into
        local first
        while read project; do
            proj_punched=0
            proj_punched=$(( 10#$(project_status "$project") ))
            if (( proj_punched ));then
                if [[ -n $insert_project ]];then
                    # another project is also punched into. which are we
                    # punching out of?
                    (( OPT_QUIET )) && die $E_USAGE
                    if [[ -n $first ]];then
                        in_projects+=($first)
                        unset first
                    fi
                    in_projects+=($project)
                else
                    # this is the only known punched-into project, so far.
                    (( n )) || first=$project #incase needed
                    insert_project=$project
                fi
                ((++n))
            fi
        done < <(db_sql "$list")

        if [[ -n $in_projects ]];then
            #loop through each project that was found, and allow user to choose:
            echo 'You are currently punched-in for multiple projects.'
            while true;do
                echo 'Which project would you like to punch out of?'
                i=0
                for proj in "${in_projects[@]}";do
                    #show a listing of possible projects
                    echo -e "[$(( $i+1 ))]:\t$proj"
                    ((++i))
                done
                #prompt user
                local prompt='[#|q]? '
                read -p $prompt ans

                #process and verify user-input
                [[ -z $ans || $ans = q ]] && die $E_ERROR
                if [[ ! "$ans" =~ $NUMERIC_REGEX ]];then
                    #user input was not numeric
                    error "'$ans' is not a number in the list."
                    continue
                fi
                ans=$(( 10#$ans ))
                if (( ans > 0 && ans <= "${#in_projects[@]}" ));then
                    #user chose a project
                    insert_project="${in_projects[$(( --ans ))]}"
                    echo "punching out of $insert_project"
                    break;
                else
                    #user input was out of range
                    error "Please choose an item number in the list."
                    continue
                fi
            done
        elif [[ -z $insert_project ]];then
            error "You are not punched into any projects, cannot assume what
            you would like to punch out of. Please see -c to specify a project
            to punch into."
            die $E_ERROR
        fi
    fi


    # run query ###############################################
    local q="
        INSERT INTO $DB_TABLE_NAME
        VALUES (
            strftime('%s', 'now'),
            $insert_status,
            '$insert_project',
            $insert_note
        );
    "
    db_sql "$q"
}

data_dump() {
    #@TODO: must respect the $OPT_CLEAN
    # will only (not) do so when not using a stupidly-slow wholy-bash function.
    local q
    q="SELECT * FROM $DB_TABLE_NAME ORDER BY punch ASC;"
    db_sql "$q"
}

project_status() {
    [[ -z $OPT_PROJECT && -z $1 ]] && return 1
    local project="${1:-$OPT_PROJECT}"
    local q="
        SELECT status
        FROM $DB_TABLE_NAME
        WHERE PROJECT='$project'
        ORDER BY PUNCH DESC
        LIMIT 0,1
    ;"
    local stat=$(db_sql "$q")
    [[ -z $stat ]] && echo 'none' || echo $stat
}

projects() {
    local t q r
    q="SELECT DISTINCT project FROM $DB_TABLE_NAME ORDER BY project ASC;"

    while read result ;do
        echo -n "$result"
        if (( ! OPT_QUIET ));then
            t=$(project_total "$result")
            (( OPT_CLEAN )) || t=$(date_fmt_colon "$t")
            echo "${PUNCH_DELIM}$t"
        else
            echo
        fi
    done < <(db_sql "$q")
}

date_fmt_colon() {
    #@TODO: where the hell is the "wheel" on this one??
    [[ "$1" =~ $NUMERIC_REGEX ]] || return 1
    declare -r stamp=$(( 10#$1 ))
    declare -A analog=(
        [y]=0
        [w]=0
        [d]=0
        [h]=0
        [m]=0
        [s]=0
    )
    analog[y]=$(( stamp / $(( 60 * 60 * 24 * 365 )) ))
    analog[w]=$(( stamp / $(( 60 * 60 * 24 * 7 )) ))
    analog[d]=$(( stamp / $(( 60 * 60 * 24 )) ))
    analog[h]=$(( stamp / $(( 60 * 60 )) ))
    analog[m]=$(( stamp / 60 ))
    analog[s]=$(( stamp % 60 ))

    local time=''
    (( analog[y] )) && time="${analog[y]} year(s), "
    (( analog[w] )) && time="${time}${analog[w]} week(s), "
    (( analog[d] )) && time="${time}${analog[d]} day(s), "
    echo "${time}${analog[h]}:${analog[m]}:${analog[s]}"
}

project_total() {
    local p=$1 i=1 s total=0
    [[ -z $p ]] && return 1
    local q="SELECT punch FROM $DB_TABLE_NAME WHERE project='$p' ORDER BY punch"

    #loop through each punch
    while read stamp;do
        if (( i % 2 ));then
            #on "start" stamp
            s="$stamp"
        else
            #on "end" stamp
            total=$(( total + $(( stamp - s )) ))
        fi
        (( ++i ))
    done < <(db_sql "$q")

    echo $total
}

remove() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        remove the in and out entries for a given timestamp, '$OPT_DELETE'
    "
}

spent() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        report a sum of time spent on a given project, '$OPT_PROJECT'
    "
    #@TODO: must respect the $OPT_CLEAN, by outputting a sum in seconds.
    #@TODO: must respect PUNCH_DELIM
}

# parse args: #################################################################
#@TODO: create a TRAP that will rollback transactions, `reset`
if (( $# ));then

    #build an array of possible options, all set to false
    declare -A OPT_RUN
    for option in "${!OPTS[@]}"; do
        OPT_RUN["${option/:/}"]=0
    done

    #parse arguments
    while getopts ":$(printf "%s" "${!OPTS[@]}")" option; do
        case $option in
            c)
                declare -r OPT_PROJECT=$OPTARG
                ;;
            C)
                #projects()
                OPT_RUN[$option]=1
                ;;
            D)
                declare -r OPT_DELETE=$OPTARG
                #remove()
                OPT_RUN[$option]=1
                ;;
            h)
                help
                ;;
            l)
                #list()
                OPT_RUN[$option]=1
                ;;
            L)
                #list()
                OPT_RUN[$option]=1
                ;;
            p)
                #punch()
                OPT_RUN[$option]=1
                ;;
            q)
                declare -r OPT_QUIET=1
                ;;
            d)
                #delete()
                OPT_RUN[$option]=1
                ;;
            s)
                declare -r OPT_CLEAN=1
                ;;
            t)
                #spent()
                OPT_RUN[$option]=1
                ;;
            \?)
                error "-$OPTARG is not a valid option. See -h for help."
                die $E_USAGE
                ;;
            :)
                error "-$OPTARG requires an argument. See -h for help."
                die $E_USAGE
                ;;
        esac
    done
  #@TODO: figure out how to make this work, only store non-getopts stuff:
  # shift $((OPTIND+1))
  # declare -r OPT_NOTE="${@}"
  # echo -e "OPT_NOTE is:\n\t${OPT_NOTE}"
else
    #no arguments were passed
    init_storage
    current
    die $?
fi

# main: #######################################################################
# - Try to run functions in a sensible sequence. ##############################

#
# Some sanity checking.
#

#functions that need a client to be specified:
if (( OPT_RUN[t] ||
    OPT_RUN[d] ||
    OPT_RUN[l] ));then
    need_client
fi

init_storage
check_schema

#
# Run one-off functions and die.
#
# for cleanliness of output
# that that covers all the db content should not be run with other functions.
#

if (( OPT_RUN[C] ));then
    projects
    die $?
fi

if (( OPT_RUN[L] ));then
    data_dump
    die $?
fi

#
# Make all changes before running any queries.
#

if (( OPT_RUN[p] ));then
    punch
fi

if (( OPT_RUN[d] ));then
    delete
fi

if (( OPT_RUN[D] ));then
    remove
fi

#
# Calculate and output all reporting.
#

if (( OPT_RUN[l] ));then
    list
fi

if (( OPT_RUN[t] ));then
    spent
fi
