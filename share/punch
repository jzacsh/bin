#!/bin/bash
 #@TODO: use this! #!/usr/bin/env bash

# also configurable via environement variables.
PUNCH_CARD=${PUNCH_CARD:-~/.config/punchcard}
PUNCH_DELIM=${PUNCH_DELIM:-' '}

# change default conf above this line. ########################################
###############################################################################

#see /usr/include/sysexits.h
E_ERROR=1  #general error
E_USAGE=64 #command line usage error
E_DATAF=65 #data format error

# functions: ##################################################################
error() {
    echo -e "Error: ${@}" >&2
}

die() {
    #@TODO: make a call to same ROLLBACK func. used by TRAP
    exit ${1:-'0'}
}

help() {
    #print the regular usage
    usage

    #build the help section
    declare -a HELP
    local i=0
    for opt in "${!OPTS[@]}"; do
        HELP[$i]=${opt/:/}
        ((++i))
    done
    i=0
    for opt in "${OPTS[@]}"; do
        local keyword=${opt%%  *}
        #@TODO: get the first keyword in output to capitalize.
        keyword=${keyword^^}
        local explain=${opt/'__'/$keyword}
        HELP[$i]="-${HELP[$i]}\t${explain/  / - }"
        ((++i))
    done

    #print help section
    echo "\
    Help Section:" >&2
    for help in "${HELP[@]}"; do
        echo -e "\t$help" >&2
    done

    die $1
}

usage() {
    local _n=$(basename $0)
    local flags=$(
        for opt in ${!OPTS[@]}; do
            [[ ${opt:1:1} = : ]] || echo -n $opt
        done
    )
    local i n
    local argflags=$(
        i=0
        for opt in ${!OPTS[@]}; do
            if [[ ${opt:1:1} = : ]];then
                (( i )) && OR=' | '
                echo -en "$OR-${opt/:/} "
                n=0
                for arg in "${OPTS[@]}"; do
                    if (( n == i ));then
                        arg=${arg%% *}
                        echo -en "${arg,,}"
                        break;
                    fi
                    ((++n))
                done
                ((++i))
            fi
        done
    )

    echo "$_n [$flags] [ $argflags ] [ note... ]
    Simple time card utility, lets you punch in, out and get paid.

    ${_n^} generally takes a client/subject of what you're working *for* and
    optionaly a quick note of what you're working *on*, then stores a timestamp
    in your local punch-card database.

    Called with no arguments ${_n^} prints your current time on the clock.
" >&2

    (( $# )) && die ${@}
}

# getops configuration: #######################################################

declare -A OPTS
OPTS=(
    [p]='Punch in/out for a "client"/"project" being referenced. See -c.'
    [d:]='timestamp  Delete all in/out time-card entries at epoch "__".'
    [h]='Help message.'
    [l]='List all time-card entries, for every project.'
    [L]='List all time-card made under a project. See -c.'
#   [n:]='note  Note about this particular card-punch "__". See -p.'
    [c:]='client  Specify the project/client being referenced, "__".'
    [q]='Quiet mode, print minimal output and even fail quietly.'
    [r]='name  Delete all time-card entries made under a project. See -c.'
    [s]='Output timestamps as epoch, intended as shell input. See eval(1p).'
    [t]='Sum of total time-card entries under project. See -c.'
)


# helpers: ####################################################################

#@TODO:
# make tiny note here about schema
CREATE_TABLE='
CREATE TABLE punch (
    punch       INTEGER PRIMARY KEY,
    status      INTEGER,
    project     TEXT,
    note        TEXT
);
'

db_sql() {
    sqlite3 $PUNCH_CARD "${@}"
}

db_schema() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        (somehow) check \$CREATE_TABLE against sqlite3's '.schema' command
    "
    return 99
}

db_create() {
    db_sql $CREATE_TABLE
}

db_punch() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
      will INSERT into DB with notes, after taking care of logic:
      - what is state of timecard? in or out?
    "
    return 99
}

create_db() {
    local initialize
    echo -en "Would you like to initialize a punch-card, here:
\t$PUNCH_CARD ?"
    local prompt=" [Y\n]  "
    read -p $prompt initialize
    [[ -z $initialize || ${initialize,,} = y ]] || return 1
    db_sql "$CREATE_TABLE"
}

reset() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        create a ROLLBACK call for call by TRAP and DIE.
    "
    return 99
}

# sanity-checks: ##############################################################

init() {
    if [[ $(file -bL $PUNCH_CARD 2>/dev/null | grep -i 'sqlite') ]];then
        #punch card looks like an sqlite file.
        if [[ ! -w $PUNCH_CARD ]];then
            error "No write-access to punch-card."
            die $E_DATAF
        fi
    else
        #punch card does not look like an sqlite file.
        if [[ -f $PUNCH_CARD ]];then
            #punch card at least likes like _some_ kind of file.
            if (( 10#$(stat -L --printf='%s' $PUNCH_CARD 2>/dev/null) ));then
                #punch card has something else in it.
                error "punch-card does not seem to be an sqlite3 database:\n\t$(file -L $PUNCH_CARD)"
                die $E_DATAF
            else
                #punch card is an empty file. create tables?
                [[ -w $PUNCH_CARD && -r $PUNCH_CARD ]] && create_db || die $?
            fi
        else
            #punch card does not exist. create it?
            error "Could not find punch-card\n\twas expecting: '$PUNCH_CARD'."
            [[ -w $(dirname $PUNCH_CARD) ]] && create_db || die $?
        fi
    fi
}

# punchcard tools: ############################################################

current() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
      report on current punch-card status.
      - are you punched into a project? how long, so far and which project?
      - not punched into anything? print a message saying so and exit non-zero
    "

    db_sql "SELECT strftime('%s', 'now');" #@TODO: remove this line!
    #@TODO: must respect the $OPT_CLEAN, and not print PROJECT name
}

punch() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
      create a database entry with current time stamp for
      \$OPT_PROJECT, either the in or out entry, depending on what is
      currently in the database.
    "
}

delete() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        remove all entries for PROJECT
    "
}

list() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        list all existing timecard entries in the database, optionally under a
    "
    #@TODO: must respect the $OPT_CLEAN
}

projects() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        list all PROJECTS on your timecard in two columns, eg.:
        [project] [total time]
        ...
    "
    #@TODO: must respect the $OPT_CLEAN
}

query() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        get a listing of all timecard entries for a given PROJECT
    "
}

remove() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        remove the in and out entries for a given timestamp
    "
}

spent() {
    #@TODO:
    error "$FUNCNAME() not yet implemented
    will:
        report a sum of time spent on a given PROJECT
    "
    #@TODO: must respect the $OPT_CLEAN, by outputting a sum in seconds.
}

# parse args: #################################################################
#@TODO: create a TRAP that will rollback transactions, `reset`
if (( $# ));then
    #parse arguments
    declare -a OPT_RUN
    while getopts ":$(printf "%s" "${!OPTS[@]}")" option; do
        case $option in
            c)
                declare -r OPT_PROJECT=$OPTARG
                ;;
            d)
                declare -r OPT_DELETE=$OPTARG
                #delete()
                OPT_RUN+=($option)
                ;;
            h)
                help
                ;;
            l)
                #list()
                OPT_RUN+=($option)
                ;;
            L)
                #list()
                OPT_RUN+=($option)
                ;;
            p)
                #punch()
                OPT_RUN+=($option)
                ;;
            q)
                declare -r OPT_QUIET=1
                ;;
            r)
                #remove()
                OPT_RUN+=($option)
                ;;
            s)
                declare -r OPT_CLEAN=1
                ;;
            t)
                #spent()
                OPT_RUN+=($option)
                ;;
            \?)
                error "-$OPTARG is not a valid option. See -h for help."
                die $E_USAGE
                ;;
            :)
                error "-$OPTARG requires an argument. See -h for help."
                die $E_USAGE
                ;;
        esac
    done
    delcare -r OPT_NOTE=${@}
else
    #no arguments were passed
    init
    current
    die $?
fi

# main: #######################################################################
init
echo -e "OPT_RUN is:\n\t${OPT_RUN[@]}"
#@TODO: fix all the below calls and above functions to match the new getopts
# string
#@TODO: run in_array() style checks to see how to behave next.
